#!/usr/bin/python3
#
# Copyright (C) 2016 Canonical, Ltd.
# Author: Martin Pitt <martin.pitt@ubuntu.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 3.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

'''netplan command line'''

import argparse
import logging
import os
import sys
import subprocess
from glob import glob

path_generate = os.environ.get('NETPLAN_GENERATE_PATH', '/lib/netplan/generate')


def parse_args():
    parser = argparse.ArgumentParser(description='netplan commands')
    parser.add_argument('--debug', action='store_true',
                        help='Enable debug messages')
    subparsers = parser.add_subparsers(title='Available commands (see "netplan <command> --help")',
                                       metavar='', dest='command')

    # command: generate
    p_generate = subparsers.add_parser('generate',
                                       help='Generate backend specific configuration files from /etc/netplan/*.yaml.')
    p_generate.add_argument('--root-dir',
                            help='Search for and generate configuration files in this root directory instead of /')

    # command: apply
    p_generate = subparsers.add_parser('apply',
                                       help='Apply current netplan config to running system (use with care!)')

    args = parser.parse_args()

    if not args.command:
        parser.error('You need to specify a command')
    return args


def nm_running():  # pragma: nocover (covered in autopkgtest)
    '''Check if NetworkManager is running'''

    try:
        subprocess.check_call(['nmcli', 'general'], stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)
        return True
    except (OSError, subprocess.SubprocessError):
        return False


def replug(device):  # pragma: nocover (covered in autopkgtest)
    '''Unbind and rebind device if it is down'''

    devdir = os.path.join('/sys/class/net', device)

    try:
        with open(os.path.join(devdir, 'operstate')) as f:
            state = f.read().strip()
            if state != 'down':
                logging.debug('device %s operstate is %s, not replugging', device, state)
                return False
    except IOError as e:
        logging.error('Cannot determine operstate of %s: %s', device, str(e))
        return False

    # /sys/class/net/ens3/device -> ../../../virtio0
    # /sys/class/net/ens3/device/driver -> ../../../../bus/virtio/drivers/virtio_net
    try:
        devname = os.path.basename(os.readlink(os.path.join(devdir, 'device')))
    except IOError as e:
        logging.debug('Cannot replug %s: cannot read link %s/device: %s', device, devdir, str(e))
        return False

    try:
        # we must resolve symlinks here as the device dir will be gone after unbind
        driver = os.path.realpath(os.path.join(devdir, 'device', 'driver'))
        if os.path.basename(driver) == 'mac80211_hwsim':
            logging.debug('replug %s: mac80211_hwsim does not support rebinding, ignoring', device)
            return False
        logging.debug('replug %s: unbinding %s from %s', device, devname, driver)
        with open(os.path.join(driver, 'unbind'), 'w') as f:
            f.write(devname)
        logging.debug('replug %s: rebinding %s to %s', device, devname, driver)
        with open(os.path.join(driver, 'bind'), 'w') as f:
            f.write(devname)
    except IOError as e:
        logging.error('Cannot replug %s: %s', device, str(e))
        return False

    return True


def command_generate():
    argv = [path_generate]
    if args.root_dir:
        argv += ['--root-dir', args.root_dir]
    logging.debug('command generate: running %s', argv)
    os.execv(argv[0], argv)


def command_apply():  # pragma: nocover (covered in autopkgtest)
    if subprocess.call([path_generate]) != 0:
        sys.exit(1)

    devices = os.listdir('/sys/class/net')

    restart_networkd = bool(glob('/run/systemd/network/*netplan-*'))
    restart_nm = bool(glob('/run/NetworkManager/system-connections/netplan-*'))

    # stop backends
    if restart_networkd:
        logging.debug('netplan generated networkd configuration exists, restarting networkd')
        subprocess.check_call(['systemctl', 'stop', '--no-block', 'systemd-networkd.service'])
    else:
        logging.debug('no netplan generated networkd configuration exists')

    if restart_nm:
        logging.debug('netplan generated NM configuration exists, restarting NM')
        if nm_running():
            # restarting NM does not cause new config to be applied, need to shut down devices first
            for device in devices:
                # ignore failures here -- some/many devices might not be managed by NM
                subprocess.call(['nmcli', 'device', 'disconnect', device], stderr=subprocess.DEVNULL)
            subprocess.check_call(['systemctl', 'stop', '--no-block', 'NetworkManager.service'])
    else:
        logging.debug('no netplan generated NM configuration exists')

    # force-hotplug all "down" network interfaces to apply renames
    any_replug = False
    for device in devices:
        if replug(device):
            any_replug = True
    if any_replug:
        subprocess.check_call(['udevadm', 'settle'])

    # (re)start backends
    if restart_networkd:
        subprocess.check_call(['systemctl', 'start', '--no-block', 'systemd-networkd.service'])
    if restart_nm:
        subprocess.call(['systemctl', 'start', '--no-block', 'NetworkManager.service'])


#
# main
#

args = parse_args()

if args.debug:
    logging.basicConfig(level=logging.DEBUG)
    os.environ['G_MESSAGES_DEBUG'] = 'all'

eval('command_' + args.command)()
